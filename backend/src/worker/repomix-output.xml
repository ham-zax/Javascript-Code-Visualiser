This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
loopTracer.js
preserveLoc.js
traceFunctions.js
traceLines.js
traceLoops.js
traceScope.js
traceVariables.js
worker.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="loopTracer.js">
const traceLoops = (babel) => {
  const t = babel.types;
  // Use a symbol specific to this plugin or reuse a shared one if appropriate
  const LOOP_TRACED = Symbol("loopTraced");

  const transformLoop = (path) => {
    // Prevent double instrumentation if plugin runs multiple times for any reason
    if (path.node[LOOP_TRACED]) return;

    // --- Create the Tracer.iterateLoop() call ---
    const iterateLoop = t.memberExpression(
      t.identifier('Tracer'),
      t.identifier('iterateLoop'),
    );
    const callIterateLoop = t.callExpression(iterateLoop, []);
    const callStatement = t.expressionStatement(callIterateLoop);
    // Mark the *call statement itself* so traceLines ignores it if needed
    // (Using a shared symbol like 'ALREADY' from traceLines might be better)
    // callStatement[ALREADY] = true; // Assuming ALREADY is defined/imported if used


    // --- Ensure the loop body is a BlockStatement ---
    let bodyPath = path.get('body');
    if (!bodyPath.isBlockStatement()) {
      // If body exists but isn't a block, wrap it
      if (bodyPath.node) {
        bodyPath.replaceWith(t.blockStatement([bodyPath.node]));
      } else {
        // Handle loops with empty bodies (e.g., for(;;);)
        // Replace the non-existent body path with an empty block
        bodyPath.replaceWith(t.blockStatement([]));
      }
      // IMPORTANT: Re-fetch the bodyPath after replacing it
      bodyPath = path.get('body');
    }

    // --- Add the tracing call to the end of the BlockStatement body ---
    // We now know bodyPath definitely points to a BlockStatement
    bodyPath.pushContainer('body', callStatement);

    // Mark the original loop node as processed by this plugin
    path.node[LOOP_TRACED] = true;
  };

  return {
    visitor: {
      // Use Babel's "Loop" shorthand to visit all loop types
      "Loop": transformLoop,
      // Or list them individually if needed:
      // WhileStatement: transformLoop,
      // DoWhileStatement: transformLoop,
      // ForStatement: transformLoop,
      // ForInStatement: transformLoop,
      // ForOfStatement: transformLoop,
    }
  };
};

module.exports = { traceLoops }; // Make sure to export correctly
</file>

<file path="preserveLoc.js">
// preserveLoc.js
module.exports = function preserveLoc() {
  return {
    visitor: {
      Program(path) {
        path.traverse({
          enter(p) {
            if (p.node && p.node.loc) {
              // stash away the original location 
              p.node.__origLoc = p.node.loc;
            }
          }
        });
      }
    }
  };
};
</file>

<file path="traceFunctions.js">
// backend/src/worker/traceFunctions.js
module.exports = function traceFunctions({ types: t }) {
  const FUNCTION_TRACED = Symbol("functionTraced");
  const isTraceableFunction = (path) =>
    path.isFunctionDeclaration() ||
    path.isFunctionExpression() ||
    path.isArrowFunctionExpression();

  // Add a flag to see if the visitor ran at all
  let visitorRan = false;

  return {
    visitor: {
      Function(path) {
        visitorRan = true; // Mark that the visitor was entered
        console.log(`[traceFunctions] Entered Function visitor for node type: ${path.node.type}, Name: ${path.node.id?.name || '(anon)'}`); // Log entry

        if (!isTraceableFunction(path)) {
          console.log(`[traceFunctions] Skipping non-traceable function type: ${path.node.type}`);
          return;
        }

        let functionBodyPath = path.get("body");
        console.log(`[traceFunctions] Got body path. Is block? ${functionBodyPath.isBlockStatement()}`);

        // 1. Ensure we have a BlockStatement body (Copied from user feedback)
        if (!functionBodyPath.isBlockStatement()) {
          // Handle arrow function implicit return: Convert expression body to block
          if (functionBodyPath.node) {
             // Check if it's null/undefined before wrapping
             if (functionBodyPath.node.type) {
                const expressionBody = functionBodyPath.node;
                functionBodyPath.replaceWith(t.blockStatement([t.returnStatement(expressionBody)]));
                // We mutated the path, re-fetch the path to the new block statement
                functionBodyPath = path.get("body");
                console.log(`[traceFunctions] Converted expression body to block.`); // Log conversion
             } else {
                 console.warn("traceFunctions: Encountered function with null/undefined body, skipping.", path.node);
                 return; // Cannot instrument non-existent body
             }
          } else {
            console.warn("traceFunctions: Cannot find body path for function, skipping.", path.node);
            return; // Cannot instrument non-existent body
          }
        }


        if (!functionBodyPath || !functionBodyPath.node) {
             console.error("[traceFunctions] ERROR: Could not get valid body path after potential conversion.");
             return;
        }

        // 2. Guard: Check if already instrumented (Copied from user feedback)
        if (functionBodyPath.node[FUNCTION_TRACED]) {
          console.log(`[traceFunctions] Body already traced, skipping.`);
          return;
        }

        console.log(`[traceFunctions] Proceeding to instrument function: ${path.node.id?.name || '(anon)'}`);

        // 3. Prepare IDs and Tracer arguments (Copied from user feedback)
        const traceId = path.scope.generateUidIdentifier("traceId");
        let fnName = 'anonymous';
        if (path.node.id) {
            fnName = path.node.id.name;
        } else if (path.parentPath.isVariableDeclarator() && path.parentPath.get('id').isIdentifier()) {
            fnName = path.parentPath.get('id').node.name;
        } else if (path.parentPath.isObjectProperty() && path.parentPath.get('key').isIdentifier()) {
           fnName = path.parentPath.get('key').node.name;
        } else if (path.parentPath.isClassMethod()) {
           fnName = path.parentPath.get('key').node.name;
        }
        const start = path.node.loc ? t.numericLiteral(path.node.loc.start.line) : t.nullLiteral();
        const end = path.node.loc ? t.numericLiteral(path.node.loc.end.line) : t.nullLiteral();
        const errorParam = path.scope.generateUidIdentifier("err");

        // Retrieve scopeId from traceScope.js
        let scopeId = "global";
        if (path.scope && path.scope.data && path.scope.data.scopeId) {
          scopeId = path.scope.data.scopeId;
        }

        // Placeholders for thisBinding and callSiteLine (can be null for now)
        const thisBinding = t.nullLiteral();
        const callSiteLine = t.nullLiteral();

        // 4. Create Tracer calls as AST nodes (Copied from user feedback & FIXED placeholders)
        const enterCall = t.expressionStatement(
          t.callExpression(
            t.memberExpression(t.identifier("Tracer"), t.identifier("enterFunc")),
            [
              traceId,
              t.stringLiteral(fnName),
              start,
              end,
              t.stringLiteral(scopeId), // newScopeId
              thisBinding,
              callSiteLine
            ]
          )
        );
        const errorMessageExpr = t.logicalExpression('||',
            t.memberExpression(errorParam, t.identifier("message")),
            t.stringLiteral('Unknown Error')
        );
        const errorCall = t.expressionStatement( // Fixed placeholder
          t.callExpression(
            t.memberExpression(t.identifier("Tracer"), t.identifier("errorFunc")),
            [errorMessageExpr, traceId, t.stringLiteral(fnName), start, end]
          )
        );
        const exitCall = t.expressionStatement( // Fixed placeholder
          t.callExpression(
            t.memberExpression(t.identifier("Tracer"), t.identifier("exitFunc")),
            [
              traceId,
              t.stringLiteral(fnName),
              start,
              end,
              t.stringLiteral(scopeId), // exitingScopeId
              t.nullLiteral(), // returnValue placeholder
              t.nullLiteral()  // returnLine placeholder
            ]
          )
        );
        const throwStmt = t.throwStatement(errorParam);


        // 5. Create the try/catch/finally structure (Copied from user feedback)
        const currentBodyBlock = functionBodyPath.node;
        const catchClause = t.catchClause(errorParam, t.blockStatement([errorCall, throwStmt]));
        // Remove exitCall from finally, it will be handled by ReturnStatement visitor
        const finallyBlock = t.blockStatement([]); // Empty finally for now
        const tryCatchFinally = t.tryStatement(
          currentBodyBlock,
          catchClause,
          finallyBlock // Now potentially empty
        );

        // Duplicated block removed

        // 6. Create the new overall function body block (Copied from user feedback)
        const newBody = t.blockStatement([
          t.variableDeclaration("const", [t.variableDeclarator(traceId, t.callExpression(t.identifier("nextId"), []))]),
          enterCall, // enterCall is now correctly defined above
          tryCatchFinally
        ]);

        // 7. Mark the *new* body block as traced (Copied from user feedback)
        newBody[FUNCTION_TRACED] = true;


        // Add logs before and after critical steps like replaceWith
        try {
            console.log(`[traceFunctions] Replacing body for: ${fnName}`); // Use determined fnName

            // --- Attempt to copy location info ---
            t.inherits(newBody, functionBodyPath.node); // Use Babel's inheritance helper
            // --- End loc copy attempt ---

            functionBodyPath.replaceWith(newBody); // newBody is the BlockStatement with try/catch etc.
            console.log(`[traceFunctions] Body replaced successfully for: ${fnName}`);

            console.log(`[traceFunctions] Crawling scope for: ${fnName}`);
            path.scope.crawl();
            console.log(`[traceFunctions] Scope crawled for: ${fnName}`);

        } catch (e) {
            console.error(`[traceFunctions] !!!!! ERROR during instrumentation !!!!!`, e);
            // Log details about the path/node if possible
            console.error(`[traceFunctions] Error occurred on node type: ${path.node.type}, name: ${fnName}`);
        }
      },

      ReturnStatement(path) {
        // Ensure this return is directly within a function we've instrumented, not a nested one.
        const funcPath = path.getFunctionParent();
        if (!funcPath || !funcPath.isFunction() || !funcPath.node?.body?.[FUNCTION_TRACED]) {
            // If the parent function's body wasn't marked by our Function visitor, skip.
            // This check might need refinement depending on exact visitor order and marking strategy.
            // console.log("[traceFunctions] Skipping ReturnStatement in non-instrumented/nested function.");
            return;
        }

        console.log(`[traceFunctions] Instrumenting ReturnStatement at line: ${path.node.loc?.start.line}`);

        // 1. Capture original return value and line
        const originalArgument = path.node.argument;
        const returnLine = path.node.loc ? t.numericLiteral(path.node.loc.start.line) : t.nullLiteral();

        // 2. Create temporary variable
        const tempVarId = path.scope.generateUidIdentifier("_tempReturnValue");
        const tempVarDecl = t.variableDeclaration("const", [
            t.variableDeclarator(
                tempVarId,
                originalArgument ? t.cloneNode(originalArgument) : t.identifier('undefined') // Clone to avoid issues
            )
        ]);
        t.inherits(tempVarDecl, path.node); // Attempt to copy location

        // 3. Re-gather info needed for Tracer.exitFunc
        // traceId should be in scope from the Function visitor's newBody
        const traceIdIdentifier = t.identifier("traceId"); // Assume it's accessible

        let fnName = 'anonymous';
        if (funcPath.node.id) {
            fnName = funcPath.node.id.name;
        } else if (funcPath.parentPath.isVariableDeclarator() && funcPath.parentPath.get('id').isIdentifier()) {
            fnName = funcPath.parentPath.get('id').node.name;
        } else if (funcPath.parentPath.isObjectProperty() && funcPath.parentPath.get('key').isIdentifier()) {
           fnName = funcPath.parentPath.get('key').node.name;
        } else if (funcPath.parentPath.isClassMethod()) {
           fnName = funcPath.parentPath.get('key').node.name;
        }
        const start = funcPath.node.loc ? t.numericLiteral(funcPath.node.loc.start.line) : t.nullLiteral();
        const end = funcPath.node.loc ? t.numericLiteral(funcPath.node.loc.end.line) : t.nullLiteral();

        // Scope ID lookup (might need improvement for complex cases)
        let scopeId = "global";
        let currentScope = path.scope;
        while (currentScope) {
            if (currentScope.data && currentScope.data.scopeId) {
                scopeId = currentScope.data.scopeId;
                break;
            }
            if (currentScope.path === funcPath) break; // Stop at function boundary
            currentScope = currentScope.parent;
        }
         if (scopeId === "global" && funcPath.scope?.data?.scopeId) { // Fallback to function scope if needed
             scopeId = funcPath.scope.data.scopeId;
         }


        // 4. Create the specific Tracer.exitFunc call
        const exitCallSpecific = t.expressionStatement(
            t.callExpression(
                t.memberExpression(t.identifier("Tracer"), t.identifier("exitFunc")),
                [
                    traceIdIdentifier,
                    t.stringLiteral(fnName),
                    start,
                    end,
                    t.stringLiteral(scopeId), // exitingScopeId
                    tempVarId, // The captured return value
                    returnLine // Line of the original return statement
                ]
            )
        );
        t.inherits(exitCallSpecific, path.node); // Attempt to copy location

        // 5. Create the new return statement
        const newReturnStmt = t.returnStatement(tempVarId);
        t.inherits(newReturnStmt, path.node); // Attempt to copy location

        // 6. Create the replacement block
        const replacementBlock = t.blockStatement([
            tempVarDecl,
            exitCallSpecific,
            newReturnStmt
        ]);
        t.inherits(replacementBlock, path.node); // Attempt to copy location

        // 7. Replace the original ReturnStatement path
        try {
            path.replaceWith(replacementBlock);
            console.log(`[traceFunctions] Replaced ReturnStatement with block at line: ${path.node?.loc?.start.line || 'unknown'}`);
            path.skip(); // Prevent re-visiting the nodes within the new block immediately
        } catch (e) {
            console.error(`[traceFunctions] !!!!! ERROR during ReturnStatement replacement !!!!!`, e);
            console.error(`[traceFunctions] Error occurred on ReturnStatement at line: ${path.node?.loc?.start.line || 'unknown'}`);
        }
      },

      // Add Program.exit to see if the visitor ran at all during the file processing
      Program: {
          exit() {
              if (!visitorRan) {
                   console.warn("[traceFunctions] WARNING: Function visitor never ran during Babel pass!");
              } else {
                   console.log("[traceFunctions] Visitor pass completed.");
              }
          }
      }
    },
  };
};
</file>

<file path="traceLines.js">
// backend/src/worker/traceLines.js
const STEP_ADDED = Symbol("stepAdded");
const SKIP_NAMES = new Set([
  'Tracer',
  'nextId',
  'fetch',
  '_',
  'lodash',
  'console',
  'setTimeout',
  'queueMicrotask'
]);

// Corrected function signature to accept (babel, options)
module.exports = function traceLines(babel, options = {}) { // Use standard signature
    console.log('[traceLines] >>> Received options argument:', options); // Log the options object
    const { types: t } = babel; // Extract types after logging
    const originalSource = options ? options.originalSource : null; // Safer access
  const originalLines = originalSource ? originalSource.split('\n') : null;

  // Add log to verify originalLines
  console.log(`[traceLines] Initialized. originalLines: ${originalLines ? `Array[${originalLines.length}]` : 'null'}`);

  return {
    visitor: {
      Statement(path) {
        // Use preserved location as fallback
        const effectiveLoc = path.node.loc || path.node.__origLoc;
        const currentLine = effectiveLoc?.start?.line;

        console.log(`[traceLines] Visiting ${path.type} at effective L${currentLine || '?'}`);

        // --- Check specifically for L5 using effective location ---
        let isL5ExprStmt = false;
        if (currentLine === 5 && path.isExpressionStatement()) {
            isL5ExprStmt = true;
            const hasLoc = !!path.node.loc;
            const hasOrigLoc = !!path.node.__origLoc;
            console.log(`[traceLines] >>> Inspecting L5 Node: Has .loc? ${hasLoc}. Has .__origLoc? ${hasOrigLoc}.`);
            if (hasOrigLoc) console.log("[traceLines] L5 __origLoc Content:", JSON.stringify(path.node.__origLoc));
            if (hasLoc) console.log("[traceLines] L5 .loc Content:", JSON.stringify(path.node.loc));
        }
        // --- End L5 check ---

        if (path.isFunctionDeclaration()) {
            console.log(`[traceLines] Skipping FunctionDeclaration.`);
            return; // Skip these
        }
        if (path.node[STEP_ADDED]) {
            console.log(`[traceLines] Skipping already instrumented node L${currentLine || '?'}`);
            return; // Skip already processed
        }
        // Skip internal calls (check before loc) - simplified check
        if (path.isExpressionStatement() && path.get('expression').isCallExpression()) {
          const callee = path.get('expression.callee');
          if (callee.isIdentifier() && SKIP_NAMES.has(callee.node.name)) {
             console.log(`[traceLines] Skipping internal call statement (direct).`);
             return;
          }
          if (callee.isMemberExpression() && callee.get('object').isIdentifier() && SKIP_NAMES.has(callee.get('object').node.name)) {
             console.log(`[traceLines] Skipping internal call statement (member).`);
             return;
          }
        }

        // --- Determine if step can be added based on effectiveLoc ---
        let canAddStep = false;
        let line, column, originalSnippet = "";

        // CRITICAL: Check originalLines here
        if (effectiveLoc && effectiveLoc.start && effectiveLoc.start.line != null && originalLines) {
             line = effectiveLoc.start.line;
             column = effectiveLoc.start.column;
             const lineIndex = line - 1;
             if (lineIndex >= 0 && lineIndex < originalLines.length) {
                 originalSnippet = originalLines[lineIndex].trim();
                 canAddStep = true;
                 if(line === 5) console.log(`[traceLines] L5 - canAddStep is TRUE.`);
             } else {
                 console.warn(`[traceLines] Line number ${line} out of bounds. Snippet unavailable.`);
             }
        } else {
            // Log why it failed
            if (isL5ExprStmt) {
                 console.log(`[traceLines] L5 Node cannot add step. Reason: effectiveLoc=${!!effectiveLoc}, start=${!!effectiveLoc?.start}, line=${effectiveLoc?.start?.line}, originalLines=${!!originalLines}`);
            } else {
                 console.log(`[traceLines] Node cannot add step at L${currentLine || '?'}. Reason: effectiveLoc=${!!effectiveLoc}, start=${!!effectiveLoc?.start}, line=${effectiveLoc?.start?.line}, originalLines=${!!originalLines}`);
            }
        }
        // --- End Check ---

        if (canAddStep) {
            // Determine statementType from node type
            let statementType = "other";
            if (path.isExpressionStatement() && path.get('expression').isAssignmentExpression()) {
              statementType = "assignment";
            } else if (path.isReturnStatement()) {
              statementType = "return";
            } else if (path.isExpressionStatement() && path.get('expression').isCallExpression()) {
              statementType = "call";
            } else if (path.isVariableDeclaration()) {
              statementType = "declaration";
            } else if (path.isIfStatement()) {
              statementType = "if";
            } else if (path.isForStatement() || path.isWhileStatement() || path.isDoWhileStatement()) {
              statementType = "loop";
            }

            // Create call statement using the determined line, column, snippet, and statementType
            const callStatement = t.expressionStatement(
              t.callExpression(
                t.memberExpression(t.identifier("Tracer"), t.identifier("step")),
                [
                  t.numericLiteral(line),
                  t.numericLiteral(column),
                  t.stringLiteral(originalSnippet),
                  t.stringLiteral(statementType)
                ]
              )
            );
            callStatement[STEP_ADDED] = true; // Mark generated node

            console.log(`[traceLines] Preparing step for L${line}: "${originalSnippet}".`);
            const parentBlockOrProgram = path.findParent((p) => p.isBlockStatement() || p.isProgram());
            if (parentBlockOrProgram) {
                 // Find the key and index where the current statement resides within the parent's body
                 let found = false;
                 const bodyKey = parentBlockOrProgram.node.body && Array.isArray(parentBlockOrProgram.node.body) ? 'body' :
                               parentBlockOrProgram.node.directives && Array.isArray(parentBlockOrProgram.node.directives) ? 'directives' :
                               null;

                 if (bodyKey) {
                    const bodyPaths = parentBlockOrProgram.get(bodyKey);
                    if (Array.isArray(bodyPaths)) {
                        for (let i = 0; i < bodyPaths.length; i++) {
                            if (bodyPaths[i].node === path.node) {
                                console.log(`[traceLines] Found statement at index ${i} in parent ${parentBlockOrProgram.type}. Inserting step before index ${i}.`);
                                try {
                                     bodyPaths[i].insertBefore(callStatement); // Insert before the path at this index
                                     console.log(`[traceLines] Inserted step successfully for L${line}.`);
                                     path.node[STEP_ADDED] = true; // Mark original node
                                     found = true;
                                     break; // Exit loop once inserted
                                } catch (e) {
                                    console.error(`[traceLines] !!!!! ERROR during insertBefore (index ${i}) !!!!! for ${path.type} at L${line}.`, e);
                                }
                            }
                        }
                    } else {
                         console.warn(`[traceLines] Parent body path (${bodyKey}) is not an array for L${line}. Cannot insert step.`);
                    }
                } else {
                     console.warn(`[traceLines] Could not determine body key for parent ${parentBlockOrProgram.type} for L${line}. Cannot insert step.`);
                }

                if (!found && !path.removed) {
                     console.warn(`[traceLines] Could not find exact path index for L${line} in parent block OR path was removed. Step not added.`);
                }
            } else {
                 console.warn(`[traceLines] Could not find BlockStatement/Program parent for L${line}. Step not added.`);
            }
        }
        // No path.skip()
      }
    }
  };
};
</file>

<file path="traceLoops.js">
// backend/src/worker/loopTracer.js (Revised)
const traceLoops = (babel) => {
  const t = babel.types;
  // Use a symbol specific to this plugin or reuse a shared one if appropriate
  const LOOP_TRACED = Symbol("loopTraced");

  const transformLoop = (path) => {
    // Prevent double instrumentation if plugin runs multiple times for any reason
    if (path.node[LOOP_TRACED]) return;

    // --- Create the Tracer.iterateLoop() call ---
    const iterateLoop = t.memberExpression(
      t.identifier('Tracer'),
      t.identifier('iterateLoop'),
    );
    const callIterateLoop = t.callExpression(iterateLoop, []);
    const callStatement = t.expressionStatement(callIterateLoop);
    // Mark the *call statement itself* so traceLines ignores it if needed
    // (Using a shared symbol like 'ALREADY' from traceLines might be better)
    // callStatement[ALREADY] = true; // Assuming ALREADY is defined/imported if used


    // --- Ensure the loop body is a BlockStatement ---
    let bodyPath = path.get('body');
    if (!bodyPath.isBlockStatement()) {
      // If body exists but isn't a block, wrap it
      if (bodyPath.node) {
        bodyPath.replaceWith(t.blockStatement([bodyPath.node]));
      } else {
        // Handle loops with empty bodies (e.g., for(;;);)
        // Replace the non-existent body path with an empty block
        bodyPath.replaceWith(t.blockStatement([]));
      }
      // IMPORTANT: Re-fetch the bodyPath after replacing it
      bodyPath = path.get('body');
    }

    // --- Add the tracing call to the end of the BlockStatement body ---
    // We now know bodyPath definitely points to a BlockStatement
    bodyPath.pushContainer('body', callStatement);

    // Mark the original loop node as processed by this plugin
    path.node[LOOP_TRACED] = true;
  };

  return {
    visitor: {
      // Use Babel's "Loop" shorthand to visit all loop types
      "Loop": transformLoop,
      // Or list them individually if needed:
      // WhileStatement: transformLoop,
      // DoWhileStatement: transformLoop,
      // ForStatement: transformLoop,
      // ForInStatement: transformLoop,
      // ForOfStatement: transformLoop,
    }
  };
};

module.exports = { traceLoops }; // Make sure to export correctly
</file>

<file path="traceScope.js">
// backend/src/worker/traceScope.js
module.exports = function traceScope({ types: t }) {
  const ALREADY = Symbol("scopeInstrumented");
  const SKIP_NAMES = new Set([
    "Tracer", "nextId", "console",
    "arguments", "this",       // skip built-ins
    "_", "lodash", "fetch"
  ]);

  return {
    visitor: {
      Function(path) {
        // --- guard: only instrument once ---
        if (path.node[ALREADY]) return;
        path.node[ALREADY] = true;

        // --- Generate unique scopeId for this function ---
        const scopeId = path.scope.generateUidIdentifier("funcScopeId").name + '-' + (typeof nextId === 'function' ? nextId() : Math.floor(Math.random() * 100000));
        path.scope.data = path.scope.data || {};
        path.scope.data.scopeId = scopeId;

        // --- Determine parentId (enclosing function or global) ---
        let parentId = null;
        if (path.scope.parent && path.scope.parent.data && path.scope.parent.data.scopeId) {
          parentId = path.scope.parent.data.scopeId;
        } else {
          parentId = "global";
        }

        // --- 1) Capture parameters at function entry ---
        const params = path.node.params
          .filter(p => t.isIdentifier(p))
          .map(p => p.name);

        const paramsObjectProps = params.map(name =>
          t.objectProperty(t.identifier(name), t.identifier(name), false, true)
        );
        const captureLocalsStmt = t.expressionStatement(
          t.callExpression(
            t.memberExpression(t.identifier("Tracer"), t.identifier("captureLocals")),
            [
              t.stringLiteral(scopeId),
              t.stringLiteral(parentId),
              t.objectExpression(paramsObjectProps)
            ]
          )
        );
        captureLocalsStmt[ALREADY] = true;

        // Ensure body is a BlockStatement
        if (!t.isBlockStatement(path.node.body)) {
          path.node.body = t.blockStatement([t.returnStatement(path.node.body)]);
        }
        // Insert at top of function
        path.get("body").unshiftContainer("body", captureLocalsStmt);

        // --- 2) Robust Free-Variable Analysis for Closure ---
        const funcScope = path.scope;                   // the function’s own scope
        const boundNames = new Set(Object.keys(funcScope.bindings));
        // Also include the function’s own name (for FunctionDeclaration)
        if (path.node.id && t.isIdentifier(path.node.id)) {
          boundNames.add(path.node.id.name);
        }

        const freeNames = new Set();
        path.traverse({
          Identifier(idPath) {
            // Only real references, not declarations, keys, tracer calls, etc.
            if (!idPath.isReferencedIdentifier()) return;
            const name = idPath.node.name;
            if (SKIP_NAMES.has(name)) return;

            // Avoid instrumentation of our own captureLocals or captureClosure AST
            if (idPath.node[ALREADY]) return;

            // Find the binding (if any)
            const binding = idPath.scope.getBinding(name);
            if (!binding) {
              // No binding => likely a global; skip or include as you choose
              return;
            }
            // If the binding’s defining scope is NOT the current function’s scope,
            // then this is a free (outer) variable that we should capture.
            if (binding.scope !== funcScope) {
              freeNames.add(name);
            }
          },
          // Don’t descend into nested functions
          Function(inner) { inner.skip(); }
        });
        console.log('[traceScope Function Visitor] Identified freeNames:', freeNames);

        // Build closure‐capture only if we found any true frees
        const closureProps = Array.from(freeNames)
          .map(name =>
            t.objectProperty(t.identifier(name), t.identifier(name), false, true)
          );
       console.log('[traceScope Function Visitor] Generated closureProps:', closureProps);
        if (closureProps.length > 0) {
          console.log('[traceScope Function Visitor] Condition (closureProps.length > 0) met:', closureProps.length > 0);
          // Generate an ID for this function’s closure
          const closureId = "closure-" + (typeof nextId === 'function' ? nextId() : Math.floor(Math.random() * 100000));
          const captureClosureStmt = t.expressionStatement(
            t.callExpression(
              t.memberExpression(t.identifier("Tracer"), t.identifier("captureClosure")),
              [
                t.stringLiteral(closureId),
                t.stringLiteral(parentId),
                t.objectExpression(closureProps)
              ]
            )
          );
          console.log('[traceScope Function Visitor] Created captureClosureStmt AST node:', captureClosureStmt);
          captureClosureStmt[ALREADY] = true;

          // Insert *after* the function declaration
          const stmtParent = path.getStatementParent();
          if (stmtParent) {
            stmtParent.insertAfter(captureClosureStmt);
            console.log('[traceScope Function Visitor] Executed stmtParent.insertAfter(captureClosureStmt)');
          }
        }
      }
    }
  };
};
</file>

<file path="traceVariables.js">
module.exports = function traceVariables({ types: t }) {
  const SKIP = new Set(["Tracer", "nextId", "console", "_", "lodash", "fetch"]);
  const ALREADY = Symbol("varAccessInstrumented");

  return {
    visitor: {
      // Wrap the RHS of x = expr as x = Tracer.varWrite("x", expr)
      AssignmentExpression(path) {
        // Prevent infinite recursion if the RHS is already a Tracer call
        if (path.get("right").isCallExpression() &&
            path.get("right.callee").isMemberExpression() &&
            path.get("right.callee.object").isIdentifier({ name: "Tracer" })) {
          return;
        }
        
        console.log(`[traceVariables] AssignmentExpression: Entering for node`, path.node);
        const left = path.node.left;
        if (!t.isIdentifier(left)) return;
        const name = left.name;
        console.log(`[traceVariables] AssignmentExpression: Considering left.name = ${name}`);
        if (SKIP.has(name)) {
          console.log(`[traceVariables] AssignmentExpression: SKIP_NAMES check PASSED for ${name}`);
          return;
        } else {
          console.log(`[traceVariables] AssignmentExpression: SKIP_NAMES check FAILED for ${name}`);
        }

        // Check if already instrumented by this specific logic
        if (path.node[ALREADY]) {
          console.log(`[traceVariables] AssignmentExpression: ALREADY symbol check PASSED for ${name}`);
          return;
        } else {
          console.log(`[traceVariables] AssignmentExpression: ALREADY symbol check FAILED for ${name}`);
        }
        path.node[ALREADY] = true; // Mark the assignment expression itself

        // --- Replace current scopeId finding logic with this: ---
        let scopeId = "global"; // Default
        let currentScope = path.scope; // Start with the current node's scope
        while (currentScope) {
            // Check if the scope object itself has the data property with scopeId
            if (currentScope.data && currentScope.data.scopeId) {
                scopeId = currentScope.data.scopeId;
                console.log(`[traceVariables][${path.type}] Found scopeId '${scopeId}' for '${name}' at scope level: ${currentScope.path.type}`);
                break; // Found it!
            }
            // Check if the scope's *path* (the AST node defining the scope) has it
            // This is sometimes where plugins attach data
             else if (currentScope.path && currentScope.path.node && currentScope.path.node.data && currentScope.path.node.data.scopeId) {
                 scopeId = currentScope.path.node.data.scopeId;
                 console.log(`[traceVariables][${path.type}] Found scopeId '${scopeId}' for '${name}' on scope path node: ${currentScope.path.type}`);
                 break; // Found it!
            }
            // If it's the program scope, stop searching upwards
            if (currentScope.path && currentScope.path.isProgram()) {
                 console.log(`[traceVariables][${path.type}] Reached Program scope for '${name}', defaulting to global.`);
                 scopeId = "global"; // Ensure it's explicitly global if we hit the top
                 break;
            }
            currentScope = currentScope.parent; // Move up to the parent scope
        }
        if (!currentScope && scopeId === "global") {
            console.warn(`[traceVariables][${path.type}] Traversed scopes fully for '${name}', could not find specific scopeId, using 'global'.`);
        }
        // --- End of replacement logic ---

        // Determine valueType from path.node.right
        let valueType = "unknown";
        if (path.node.right) {
          if (t.isNumericLiteral(path.node.right)) valueType = "number";
          else if (t.isStringLiteral(path.node.right)) valueType = "string";
          else if (t.isBooleanLiteral(path.node.right)) valueType = "boolean";
          else if (t.isFunctionExpression(path.node.right) || t.isArrowFunctionExpression(path.node.right)) valueType = "function";
          else if (t.isObjectExpression(path.node.right)) valueType = "object";
          else if (t.isArrayExpression(path.node.right)) valueType = "array";
          else if (t.isNullLiteral(path.node.right)) valueType = "null";
          else if (t.isIdentifier(path.node.right) && path.node.right.name === "undefined") valueType = "undefined";
          else valueType = path.node.right.type || "unknown";
        }

        const newRight = t.callExpression(
          t.memberExpression(t.identifier("Tracer"), t.identifier("varWrite")),
          [
            t.stringLiteral(scopeId),
            t.stringLiteral(name),
            path.node.right,
            t.stringLiteral(valueType)
          ]
        );
        console.log(`[traceVariables] AssignmentExpression: Created newRight (Tracer.varWrite call) for ${name}:`, newRight);
        // Mark the new node to prevent re-instrumentation if traversal restarts
        newRight[ALREADY] = true;
        console.log(`[traceVariables] AssignmentExpression: Attempting path.get("right").replaceWith(newRight) for ${name}`);
        path.get("right").replaceWith(newRight);
        console.log(`[traceVariables] AssignmentExpression: Successfully executed path.get("right").replaceWith(newRight) for ${name}`);
        // path.skip(); // Maybe skip to prevent re-visiting the new node immediately? Test this.
      },

      // Visitor for initializations like: let x = 5; const y = 'abc'; var z = true;
      VariableDeclarator(path) {
        const idNode = path.node.id;
        const initNode = path.node.init;

        // Only instrument if there's an identifier and an initializer
        if (!t.isIdentifier(idNode) || !initNode) {
             console.log(`[traceVariables][VariableDeclarator] Skipping declarator without id/init.`);
             return;
        }

        // Prevent infinite recursion if the init is already a Tracer call (less likely now, but good safety)
         if (t.isCallExpression(initNode) &&
             t.isMemberExpression(initNode.callee) &&
             t.isIdentifier(initNode.callee.object, { name: "Tracer" })) {
             console.log(`[traceVariables][VariableDeclarator] Skipping initializer already wrapped.`);
             return;
         }


        const name = idNode.name;
        console.log(`[traceVariables] VariableDeclarator: Considering id.name = ${name}`);

        if (SKIP.has(name)) {
          console.log(`[traceVariables] VariableDeclarator: SKIP_NAMES check PASSED for ${name}`);
          return;
        } else {
          console.log(`[traceVariables] VariableDeclarator: SKIP_NAMES check FAILED for ${name}`);
        }

        // Check if already instrumented (e.g., if plugin runs multiple times)
        // We check the *declarator node* itself now, as we insert after its parent statement
        if (path.node[ALREADY]) {
          console.log(`[traceVariables] VariableDeclarator: ALREADY symbol check PASSED for ${name}`);
          return;
        } else {
          console.log(`[traceVariables] VariableDeclarator: ALREADY symbol check FAILED for ${name}`);
        }
        // Mark it later, only if insertion succeeds

        // --- Replace current scopeId finding logic with this: ---
        let scopeId = "global"; // Default
        let currentScope = path.scope; // Start with the current node's scope
        while (currentScope) {
            // Check if the scope object itself has the data property with scopeId
            if (currentScope.data && currentScope.data.scopeId) {
                scopeId = currentScope.data.scopeId;
                console.log(`[traceVariables][${path.type}] Found scopeId '${scopeId}' for '${name}' at scope level: ${currentScope.path.type}`);
                break; // Found it!
            }
            // Check if the scope's *path* (the AST node defining the scope) has it
            // This is sometimes where plugins attach data
             else if (currentScope.path && currentScope.path.node && currentScope.path.node.data && currentScope.path.node.data.scopeId) {
                 scopeId = currentScope.path.node.data.scopeId;
                 console.log(`[traceVariables][${path.type}] Found scopeId '${scopeId}' for '${name}' on scope path node: ${currentScope.path.type}`);
                 break; // Found it!
            }
            // If it's the program scope, stop searching upwards
            if (currentScope.path && currentScope.path.isProgram()) {
                 console.log(`[traceVariables][${path.type}] Reached Program scope for '${name}', defaulting to global.`);
                 scopeId = "global"; // Ensure it's explicitly global if we hit the top
                 break;
            }
            currentScope = currentScope.parent; // Move up to the parent scope
        }
        if (!currentScope && scopeId === "global") {
            console.warn(`[traceVariables][${path.type}] Traversed scopes fully for '${name}', could not find specific scopeId, using 'global'.`);
        }
        // --- End of replacement logic ---


        // Determine valueType from initNode
        let valueType = "unknown";
        if (t.isNumericLiteral(initNode)) valueType = "number";
        else if (t.isStringLiteral(initNode)) valueType = "string";
        else if (t.isBooleanLiteral(initNode)) valueType = "boolean";
        else if (t.isFunctionExpression(initNode) || t.isArrowFunctionExpression(initNode)) valueType = "function";
        else if (t.isObjectExpression(initNode)) valueType = "object";
        else if (t.isArrayExpression(initNode)) valueType = "array";
        else if (t.isNullLiteral(initNode)) valueType = "null";
        else if (t.isIdentifier(initNode) && initNode.name === "undefined") valueType = "undefined";
        else valueType = initNode.type || "unknown";

        // Create the Tracer.varWrite call expression
        // IMPORTANT: Pass the *identifier* node as the value argument for insertAfter
        const callExpr = t.callExpression(
          t.memberExpression(t.identifier("Tracer"), t.identifier("varWrite")),
          [
            t.stringLiteral(scopeId),
            t.stringLiteral(name),
            t.identifier(name), // Pass the variable's identifier node
            t.stringLiteral(valueType)
          ]
        );
        // Wrap it in an ExpressionStatement
        const callStatement = t.expressionStatement(callExpr);
        callStatement[ALREADY] = true; // Mark the generated statement to prevent re-instrumentation

        console.log(`[traceVariables] VariableDeclarator: Created VarWrite statement for ${name}`);

        // Get the parent statement (likely VariableDeclaration)
        const statementParent = path.getStatementParent();
        if (statementParent) {
          try {
             console.log(`[traceVariables] VariableDeclarator: Attempting insertAfter for ${name}`);
             statementParent.insertAfter(callStatement);
             console.log(`[traceVariables] VariableDeclarator: Successfully inserted VarWrite after declaration for ${name}`);
             // Mark original declarator node ONLY after successful insertion
             path.node[ALREADY] = true;
          } catch (e) {
             console.error(`[traceVariables][VariableDeclarator] Error inserting VarWrite for ${name}:`, e);
          }
        } else {
          console.error(`[traceVariables][VariableDeclarator] Could not find statement parent for ${name} to insert VarWrite after.`);
        }
      }, // End VariableDeclarator

      // Replace any identifier read with Tracer.varRead("id", id)
      Identifier(path) {
        // guard against double‐wrapping or instrumenting generated code
        if (path.node[ALREADY]) return;

        // Skip if not referenced (e.g., declaration, function name)
        if (!path.isReferencedIdentifier()) return;

        // Skip if the identifier is the argument of an UpdateExpression (e.g., count++ or ++count)
        if (path.parentPath.isUpdateExpression() && path.key === 'argument') {
          return;
        }

        const name = path.node.name;
        if (SKIP.has(name)) return;

        // skip parameter binding sites & callee positions
        const binding = path.scope.getBinding(name);
        if (binding && binding.kind === "param") return;
        if (path.parentPath.isCallExpression() && path.key === "callee") return; // Use path.key

        // Skip if it's the property being accessed in a member expression (e.g., obj.PROP)
        if (path.parentPath.isMemberExpression() && path.key === 'property' && !path.parentPath.node.computed) return;

        // Skip if it's a key in an object property (unless computed)
        if (path.parentPath.isObjectProperty() && path.key === 'key' && !path.parentPath.node.computed) return;

        // Skip if it's inside a Tracer call already (either callee or argument)
        const parentCall = path.findParent(p => p.isCallExpression());
        if (parentCall && parentCall.get("callee").isMemberExpression() &&
            parentCall.get("callee.object").isIdentifier({ name: "Tracer" })) {
          return;
        }

        // Mark the original node before replacing
        path.node[ALREADY] = true;

        const wrapped = t.callExpression(
          t.memberExpression(t.identifier("Tracer"), t.identifier("varRead")),
          // Pass the original identifier node itself as the value argument
          [ t.stringLiteral(name), path.node /* t.identifier(name) */ ]
        );
        // Mark the new wrapper node
        wrapped[ALREADY] = true;
        path.replaceWith(wrapped);
        // path.skip(); // Skip further traversal on the replaced node
      }
    }
  };
};
</file>

<file path="worker.js">
const { parentPort, workerData } = require('worker_threads');
const asyncHooks = require('async_hooks');
const util = require('util');
const fs = require('fs');
const babel = require('@babel/core'); // NOT 'babel-core'
const { VM } = require('vm2');

const fetch = require('node-fetch');
const _ = require('lodash');
// Falafel removed
const prettyFormat = require('pretty-format').default; // Import default export

const { traceLoops } = require('./loopTracer');
const traceLines = require('./traceLines');
// const traceScopeAndClosures = require('./traceScopeAndClosures'); // Replaced
const traceScope = require('./traceScope');             // New scope plugin
const traceVariables = require('./traceVariables');       // New variable plugin
const traceFunctions = require('./traceFunctions'); // Require the new plugin
const preserveLoc = require('./preserveLoc');

const LOG_FILE = './log.txt';
fs.writeFileSync(LOG_FILE, '');
const log = (...msg) => fs.appendFileSync(
  LOG_FILE,
  msg.map(m => _.isString(m) ? m : prettyFormat(m)).join(' ') + '\n'
);

const event = (type, payload) => ({ type, payload });
const Events = {
  ConsoleLog: (message) => event('ConsoleLog', { message }),
  ConsoleWarn: (message) => event('ConsoleWarn', { message }),
  ConsoleError: (message) => event('ConsoleError', { message }),

  EnterFunction: (id, name, start, end) => event('EnterFunction', { id, name, start, end }),
  ExitFunction: (id, name, start, end) => event('ExitFunction', { id, name, start, end }),
  ErrorFunction: (message, id, name, start, end) => event('ErrorFunction', { message, id, name, start, end }),

  InitPromise: (id, parentId) => event('InitPromise', { id, parentId }),
  ResolvePromise: (id) => event('ResolvePromise', { id }),
  BeforePromise: (id) => event('BeforePromise', { id }),
  AfterPromise: (id) => event('AfterPromise', { id }),

  InitMicrotask: (id, parentId) => event('InitMicrotask', { id, parentId }),
  BeforeMicrotask: (id) => event('BeforeMicrotask', { id }),
  AfterMicrotask: (id) => event('AfterMicrotask', { id }),

  InitTimeout: (id, callbackName) => event('InitTimeout', { id, callbackName }),
  BeforeTimeout: (id) => event('BeforeTimeout', { id }),

  // New events for enhanced tracing
  Step: (line, col, snippet) => event('Step', { line, col, snippet }),
  Locals: (locals) => event('Locals', { locals }),
  VarWrite: (name, value) => event('VarWrite', { name, value }),
  VarRead: (name, value) => event('VarRead', { name, value }),
  Closure: (fnId, bindings) => event('Closure', { fnId, bindings }),

  UncaughtError: (error) => event('UncaughtError', {
    name: (error || {}).name,
    stack: (error || {}).stack,
    message: (error || {}).message,
  }),
  EarlyTermination: (message) => event('EarlyTermination', { message }),
};

let events = [];
const postEvent = (event) => {
  events.push(event);
  parentPort.postMessage(JSON.stringify(event));
}

// We only care about these async hook types:
//   PROMISE, Timeout
const ignoredAsyncHookTypes = [
  'FSEVENTWRAP', 'FSREQCALLBACK', 'GETADDRINFOREQWRAP', 'GETNAMEINFOREQWRAP',
  'HTTPPARSER', 'JSSTREAM', 'PIPECONNECTWRAP', 'PIPEWRAP', 'PROCESSWRAP',
  'QUERYWRAP', 'SHUTDOWNWRAP', 'SIGNALWRAP', 'STATWATCHER', 'TCPCONNECTWRAP',
  'TCPSERVERWRAP', 'TCPWRAP', 'TTYWRAP', 'UDPSENDWRAP', 'UDPWRAP', 'WRITEWRAP',
  'ZLIB', 'SSLCONNECTION', 'PBKDF2REQUEST', 'RANDOMBYTESREQUEST', 'TLSWRAP',
  'DNSCHANNEL',
];
const isIgnoredHookType = (type) => ignoredAsyncHookTypes.includes(type);

// --- async_hooks setup moved below Babel transform ---

const functionDefinitionTypes = [
  'FunctionDeclaration',
  'FunctionExpression',
  'ArrowFunctionExpression',
];
const arrowFnImplicitReturnTypesRegex = /Literal|Identifier|(\w)*Expression/;

// traceBlock function removed (was Falafel-specific)

const jsSourceCode = workerData; // Keep the original source untouched
console.log("[Worker] jsSourceCode before Babel:", typeof jsSourceCode, jsSourceCode ? jsSourceCode.slice(0, 50) + '...' : 'null/undefined'); // Log type and preview

// Falafel transformation block removed

// --- Run Babel ---
let modifiedSource = '';
try {
  console.log("Starting Babel transformation..."); // Add log
  modifiedSource = babel
    .transform(jsSourceCode, { // Use original jsSourceCode here
      filename: 'userCode.js', // Optional: Good practice for sourcemaps/errors
      sourceMaps: true,      // Enable source maps
      plugins: [
        preserveLoc,                                 // 1) stash loc
        traceLoops,                                  // 2) timeout checks
        [ traceLines, { originalSource: jsSourceCode } ], // 3) step calls
        traceScope,                                  // 4) locals & closures
        traceVariables,                              // 5) varWrite & varRead
        traceFunctions                               // 6) enter/exit/errorFunc
      ]
    })
    .code;
  console.log("Babel transformation complete."); // Add log
  // Optional: Log transformed code for debugging
  log('--- Transformed Code ---');
  log(modifiedSource); // <--- UNCOMMENTED THIS
  log('--- End Transformed Code ---');
} catch (babelError) {
  console.error("Error during Babel transformation:", babelError); // Keep existing error handling
  postEvent(Events.UncaughtError({
    name: 'InstrumentationError',
    message: `Babel Transformation Error: ${babelError.message}`,
    stack: babelError.stack
  }));
  process.exit(1);
}

// --- MOVE async_hooks setup HERE ---
const asyncIdToResource = {}; // Keep resource map scoped if needed
const init = (asyncId, type, triggerAsyncId, resource) => {
  asyncIdToResource[asyncId] = resource;
  if (type === 'PROMISE') {
    postEvent(Events.InitPromise(asyncId, triggerAsyncId));
  }
  if (type === 'Timeout') {
    const callbackName = resource._onTimeout.name || 'anonymous';
    postEvent(Events.InitTimeout(asyncId, callbackName));
  }
  if (type === 'Microtask') {
    postEvent(Events.InitMicrotask(asyncId, triggerAsyncId));
  }
};
const before = (asyncId) => {
  const resource = asyncIdToResource[asyncId] || {};
  const resourceName = (resource.constructor).name;
  if (resourceName === 'PromiseWrap') {
    postEvent(Events.BeforePromise(asyncId));
  }
  if (resourceName === 'Timeout') {
    postEvent(Events.BeforeTimeout(asyncId));
  }
  if (resourceName === 'AsyncResource') {
    postEvent(Events.BeforeMicrotask(asyncId));
  }
};
const after = (asyncId) => {
  const resource = asyncIdToResource[asyncId] || {};
  const resourceName = (resource.constructor).name;
  if (resourceName === 'PromiseWrap') {
    postEvent(Events.AfterPromise(asyncId));
  }
  if (resourceName === 'AsyncResource') {
    postEvent(Events.AfterMicrotask(asyncId));
  }
};
const destroy = (asyncId) => {
  // Optional: Clean up asyncIdToResource if needed, be careful with timing
  // delete asyncIdToResource[asyncId];
};
const promiseResolve = (asyncId) => {
    // Add safety check inside the hook
    const resource = asyncIdToResource[asyncId];
    // Only post event if resource and promise exist
    if (resource && resource.promise) {
         postEvent(Events.ResolvePromise(asyncId));
    }
    // No else block, so no warning is printed
};

console.log("[Worker] Enabling async_hooks.");
asyncHooks
  .createHook({ init, before, after, destroy, promiseResolve })
  .enable();
// --- End async_hooks setup move ---

// TODO: Maybe change this name to avoid conflicts?
const nextId = (() => {
  let id = 0;
  return () => id++;
})();

const arrToPrettyStr = (arr) =>
  arr.map(a => _.isString(a) ? a : prettyFormat(a)).join(' ') + '\n'

const START_TIME = Date.now();
const TIMEOUT_MILLIS = 5000;
const EVENT_LIMIT = 500;

const Tracer = {
  // Enhanced methods for event emission

  enterFunc: (id, name, start, end, newScopeId, thisBinding, callSiteLine) => postEvent({
    type: "EnterFunction",
    payload: {
      id, name, start, end,
      newScopeId,
      thisBinding,
      callSiteLine
    }
  }),

  exitFunc: (id, name, start, end, exitingScopeId, returnValue, returnLine) => {
    // Task 3.2: Log the return value for inspection
    console.log(`[Tracer.exitFunc] id: ${id}, name: ${name}, returnValue:`, returnValue);
    console.log('[Worker Tracer.exitFunc] Received returnValue:', prettyFormat(returnValue));
    postEvent({
      type: "ExitFunction",
      payload: {
        id, name, start, end,
      exitingScopeId,
      returnValue,
      returnLine
      }
    });
  },

  errorFunc: (message, id, name, start, end) => postEvent({
    type: "ErrorFunction",
    payload: { message, id, name, start, end }
  }),

  log: (...args) => postEvent({ type: "ConsoleLog", payload: { text: arrToPrettyStr(args) } }),
  warn: (...args) => postEvent({ type: "ConsoleWarn", payload: { text: arrToPrettyStr(args) } }),
  error: (...args) => postEvent({ type: "ConsoleError", payload: { text: arrToPrettyStr(args) } }),

  // Enhanced step event
  step: (line, col, snippet, statementType) => postEvent({
    type: "Step",
    payload: { line, col, snippet, statementType }
  }),

  // Enhanced scope tracking
  _currentLocals: {},
  captureLocals: (scopeId, parentId, locals) => {
    Tracer._currentLocals = locals;
    postEvent({
      type: "Locals",
      payload: { scopeId, parentId, locals }
    });
  },

  // Enhanced variable tracking
  varWrite: (scopeId, name, val, valueType) => {
    console.log(`[Tracer.varWrite] Called with: scopeId=${scopeId}, name=${name}, val=`, val, `, valueType=${valueType}`); // Log entry and args
    console.log(`[Tracer.varWrite] Calling postEvent for VarWrite`);
    postEvent({
      type: "VarWrite",
      payload: {
        scopeId,
        name,
        val: prettyFormat(val),
        valueType
      }
    });
    console.log(`[Tracer.varWrite] postEvent called successfully`);
    return val;
  },
  varRead: (name, val) => {
    postEvent({
      type: "VarRead",
      payload: { name, val: prettyFormat(val) }
    });
    return val;
  },

  // Enhanced closure capture
  captureClosure: (closureId, parentId, bindings) => {
console.log('[Worker Tracer.captureClosure] Called with closureId:', closureId, 'parentId:', parentId, 'bindings:', bindings);
    const displayBindings = {};
    for (const key in bindings) {
      displayBindings[key] = prettyFormat(bindings[key]);
    }
console.log('[Worker Tracer.captureClosure] Posting Closure event:', { type: 'Closure', payload: { closureId, parentId, bindings: displayBindings } });
    postEvent({
      type: "Closure",
      payload: { closureId, parentId, bindings: displayBindings }
    });
  },

  // Loop termination check
  iterateLoop: () => {
    const hasTimedOut = (Date.now() - START_TIME) > TIMEOUT_MILLIS;
    const reachedEventLimit = events.length >= EVENT_LIMIT;
    const shouldTerminate = reachedEventLimit || hasTimedOut;
    if (shouldTerminate) {
      postEvent({
        type: "EarlyTermination",
        payload: {
          reason: hasTimedOut
            ? `Terminated early: Timeout of ${TIMEOUT_MILLIS} millis exceeded.`
            : `Terminated early: Event limit of ${EVENT_LIMIT} exceeded.`
        }
      });
      process.exit(1);
    }
  },
};

// E.g. call stack size exceeded errors...
process.on('uncaughtException', (err) => {
  postEvent(Events.UncaughtError(err));
  process.exit(1);
});

// Add safety check for Tracer methods if needed
if (typeof Tracer.enterFunc !== 'function' || typeof Tracer.exitFunc !== 'function' || typeof Tracer.errorFunc !== 'function') {
  throw new Error("Tracer object is missing required function tracing methods!");
}

const vm = new VM({
  timeout: 6000, // Keep existing timeout
  sandbox: {
    nextId,
    Tracer,
    fetch,
    _,
    lodash: _,
    setTimeout,
    queueMicrotask,
    prettyFormat, // <<< ADD prettyFormat TO SANDBOX
    console: {
      log: Tracer.log,
      warn: Tracer.warn,
      error: Tracer.error,
    },
  },
});

try {
  console.log("Running instrumented code in VM..."); // Add log
  vm.run(modifiedSource);
  console.log("VM execution finished."); // Add log
} catch (vmError) {
  console.error("Error during VM execution:", vmError); // Log VM errors caught here
  // Post an error event if VM itself throws (e.g., timeout, compilation)
  postEvent(Events.UncaughtError(vmError));
// Optionally re-throw or exit depending on desired worker behavior on VM errors
// process.exit(1);
}
</file>

</files>
